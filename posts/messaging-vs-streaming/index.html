<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/favicon.ico?v=1" sizes="any"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="Popov R&#38;D Blog" href="https://blog.popov-rnd.com/rss.xml"><meta name="generator" content="Astro v5.15.1"><!-- Canonical URL --><link rel="canonical" href="https://blog.popov-rnd.com/posts/messaging-vs-streaming/"><!-- Primary Meta Tags --><title>Messaging vs streaming: core architectural differences</title><meta name="title" content="Messaging vs streaming: core architectural differences"><meta name="description" content="In this article, we explore core architectural differences between messaging and streaming concepts, define boundaries and discuss use cases"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://blog.popov-rnd.com/posts/messaging-vs-streaming/"><meta property="og:title" content="Messaging vs streaming: core architectural differences"><meta property="og:description" content="In this article, we explore core architectural differences between messaging and streaming concepts, define boundaries and discuss use cases"><meta property="og:site_name" content="Popov R&D Blog"><meta property="og:image" content="https://blog.popov-rnd.com/_astro/cover.Dvd4mVuM.webp"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://blog.popov-rnd.com/posts/messaging-vs-streaming/"><meta property="twitter:title" content="Messaging vs streaming: core architectural differences"><meta property="twitter:description" content="In this article, we explore core architectural differences between messaging and streaming concepts, define boundaries and discuss use cases"><meta property="twitter:image" content="https://blog.popov-rnd.com/_astro/cover.Dvd4mVuM.webp"><script type="application/ld+json">{"@context":"https://schema.org","@type":"WebSite","url":"https://blog.popov-rnd.com","name":"Popov R&D Tech Blog","publisher":{"@type":"Organization","name":"Popov R&D","url":"https://popov-rnd.com"}}</script><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Messaging vs streaming: core architectural differences","description":"In this article, we explore core architectural differences between messaging and streaming concepts, define boundaries and discuss use cases","image":"https://blog.popov-rnd.com/_astro/cover.Dvd4mVuM.webp","datePublished":"2025-09-01T00:00:00.000Z","dateModified":"2025-09-01T00:00:00.000Z","author":{"@type":"Person","name":"Andrii Popov","url":"https://popov-rnd.com/#about-me"},"publisher":{"@type":"Organization","name":"Popov R&D","url":"https://popov-rnd.com"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.popov-rnd.com/posts/messaging-vs-streaming/"}}</script><link rel="stylesheet" href="/_astro/_slug_.BKzO6t0X.css"></head> <body class="bg-neutral-50 dark:bg-neutral-900 text-neutral-800 dark:text-neutral-200"> <header class="fixed top-0 left-0 w-full h-[65px]
         bg-gray-50 dark:bg-neutral-800
         font-default text-neutral-800 dark:text-neutral-50 font-medium
         flex items-center justify-between
         px-[1%] gap-x-[1vw] z-50 shadow-md"> <a href="/" class="flex items-center justify-center space-x-3 no-underline"> <img src="/_astro/logo.WyeL1E5S.svg" alt="Popov R&D logo" class="shrink-0 w-[45px] h-[45px] opacity-80"> <div class="flex flex-col space-y-0 text-neutral-800  dark:text-neutral-50"> <span class="text-base font-normal">POPOV R&amp;D</span> <span class="text-xs font-normal">tech blog</span> </div> </a> <!-- Desktop / Tablet --><div class="hidden md:flex items-center gap-x-[1vw]"> <nav class="flex-1 flex items-center justify-end gap-x-3 lg:gap-x-5 shrink"> <a href="/" class="relative transition-colors duration-200 text-neutral-800 dark:text-neutral-50 text-[clamp(14px,1.2vw,16px)] cursor-pointer hover:text-lime-400"> <span class="relative inline-block"> Home  </span> </a> <a href="/posts" class="relative transition-colors duration-200 text-neutral-800 dark:text-neutral-50 text-[clamp(14px,1.2vw,16px)] cursor-pointer hover:text-lime-400 font-bold"> <span class="relative inline-block"> Posts <span class="absolute left-0 -bottom-1 h-0.5 w-full bg-lime-400"></span> </span> </a> <a href="/about" class="relative transition-colors duration-200 text-neutral-800 dark:text-neutral-50 text-[clamp(14px,1.2vw,16px)] cursor-pointer hover:text-lime-400"> <span class="relative inline-block"> About  </span> </a> <a href="/search" class="relative transition-colors duration-200 text-neutral-800 dark:text-neutral-50 text-[clamp(14px,1.2vw,16px)] cursor-pointer hover:text-lime-400"> <span class="relative inline-block">  <div aria-label="Search" class="text-lg hover:text-lime-300 transition-colors"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var n=(a,t)=>{let i=async()=>{await(await a())()};if(t.value){let e=matchMedia(t.value);e.matches?i():e.addEventListener("change",i,{once:!0})}};(self.Astro||(self.Astro={})).media=n;window.dispatchEvent(new Event("astro:media"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="2fl2QU" prefix="r22" component-url="/_astro/SearchIcon.DS4bxQ8F.js" component-export="SearchIcon" renderer-url="/_astro/client.B_PwMJWB.js" props="{}" ssr client="media" opts="{&quot;name&quot;:&quot;SearchIcon&quot;,&quot;value&quot;:&quot;(min-width: 768px)&quot;}" await-children><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"></path></svg><!--astro:end--></astro-island> </div>   </span> </a> <script>
    const theme = (() => {
        const stored = localStorage?.getItem("theme") ?? '';
        if (["dark", "light"].includes(stored)) return stored;
        if (window.matchMedia("(prefers-color-scheme: dark)").matches) return "dark";
        return "light";
    })();

    document.documentElement.classList.toggle("dark", theme === "dark");

    const toggleTheme = () => {
        const el = document.documentElement;
        const isDark = el.classList.toggle("dark");
        localStorage.setItem("theme", isDark ? "dark" : "light");

        // update knob visibility
        const lightKnob = document.getElementById("lightKnob");
        const darkKnob = document.getElementById("darkKnob");
        if (lightKnob && darkKnob) {
            lightKnob.style.opacity = isDark ? "0" : "1";
            darkKnob.style.opacity = isDark ? "1" : "0";
        }
    };

    document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("themeButton")?.addEventListener("click", toggleTheme);
    });
</script> <button id="themeButton" type="button" class="relative inline-flex h-8 w-20 items-center rounded-full
	        bg-[#C1FF72]/35 dark:bg-white/10 ring-1 ring-black/5 dark:ring-white/10
	        shadow-sm transition-colors duration-200 focus:outline-none
	        focus-visible:ring-2 focus-visible:ring-[#C1FF72]
	        focus-visible:ring-offset-2 focus-visible:ring-offset-white
	        dark:focus-visible:ring-offset-neutral-900"> <!-- Light knob --> <span id="lightKnob" class="absolute top-1 h-6 w-1/2 rounded-full
                flex items-center justify-center
                font-normal text-[10.5px] tracking-widest
                bg-lime-300 text-neutral-900 shadow-sm
                transition-all duration-200 left-1 opacity-100">
Light
</span> <!-- Dark knob --> <span id="darkKnob" class="absolute top-1 h-6 w-1/2 rounded-full
                flex items-center justify-center
                font-normal text-[10.5px] tracking-widest
                bg-lime-300 text-neutral-900 shadow-sm
                transition-all duration-200 right-1 opacity-0">
Dark
</span> </button> </nav> </div> <!-- Mobile / Hamburger --> <div class="md:hidden"> <script>(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();</script><astro-island uid="grfut" prefix="r21" component-url="/_astro/MenuGroupMobile.BhdERKXX.js" component-export="MenuGroupMobile" renderer-url="/_astro/client.B_PwMJWB.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;MenuGroupMobile&quot;,&quot;value&quot;:true}" await-children><button type="button" aria-label="Open menu" class="
                inline-flex h-11 w-11 items-center justify-center
                rounded-lg focus-visible:outline-none
                focus-visible:ring-2 focus-visible:ring-prnd-accent focus-visible:ring-offset-2"><span class="relative block h-5 w-7"><span class="absolute left-0 top-0 block h-0.5 w-7 rounded bg-neutral-800 dark:bg-neutral-50 transition-transform duration-300 "></span><span class="absolute left-0 top-2.5 block h-0.5 w-7 rounded bg-neutral-800 dark:bg-neutral-50 transition-opacity duration-300 opacity-100"></span><span class="absolute right-0 top-5 block h-0.5 w-5 rounded bg-neutral-800 dark:bg-neutral-50 transition-transform duration-300 "></span></span></button><div class="
                fixed top-[65px] right-0
                h-[calc(100vh-65px)] w-full overflow-y-auto
                bg-gray-50 dark:bg-neutral-900 z-600
                transform transition-transform duration-450 ease-in-out
                translate-x-full"><nav class="flex flex-col divide-y divide-neutral-700"><a href="/" class="
                            block px-[2%]
                            py-3 sm:py-4 md:py-5
                            text-[14px] sm:text-[15px] md:text-[16px] font-medium
                            text-neutral-800
                            dark:text-neutral-50
                            hover:text-prnd-neon
                            focus-visible:outline-none focus-visible:ring-2
                            focus-visible:ring-prnd-neon">Home</a><a href="/posts" class="
                            block px-[2%]
                            py-3 sm:py-4 md:py-5
                            text-[14px] sm:text-[15px] md:text-[16px] font-medium
                            text-neutral-800
                            dark:text-neutral-50
                            hover:text-prnd-neon
                            focus-visible:outline-none focus-visible:ring-2
                            focus-visible:ring-prnd-neon">Posts</a><a href="/about" class="
                            block px-[2%]
                            py-3 sm:py-4 md:py-5
                            text-[14px] sm:text-[15px] md:text-[16px] font-medium
                            text-neutral-800
                            dark:text-neutral-50
                            hover:text-prnd-neon
                            focus-visible:outline-none focus-visible:ring-2
                            focus-visible:ring-prnd-neon">About</a><a href="/search" class="
                            block px-[2%]
                            py-3 sm:py-4 md:py-5
                            text-[14px] sm:text-[15px] md:text-[16px] font-medium
                            text-neutral-800
                            dark:text-neutral-50
                            hover:text-prnd-neon
                            focus-visible:outline-none focus-visible:ring-2
                            focus-visible:ring-prnd-neon">Search</a></nav></div><!--astro:end--></astro-island> </div> </header> <main class="pt-[65px] w-full max-w-3xl mx-auto px-4 sm:px-8 lg:px-0 py-6 font-article"> <nav aria-label="Back to posts" class="text-left py-6"> <a href="/posts" class="
                inline-flex items-center justify-center
                px-2 py-1
                bg-transparent
                border
                rounded-xl
                text-sm
                font-semibold
                text-neutral-600 dark:text-neutral-200
                hover:border-none hover:rounded-xl hover:bg-neutral-800 dark:hover:bg-neutral-50  hover:text-prnd-neon dark:hover:text-neutral-700
                active:rounded-xl active:bg-neutral-800 dark:active:bg-neutral-50  active:text-neutral-50 dark:active:text-neutral-800
                focus:outline-none focus:ring-2 focus:ring-offset-2 hover:scale-110 active:scale-95
                transition-all duration-500 ease-in-out"><svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9.707 4.293a1 1 0 010 1.414L6.414 9H16a1 1 0 110 2H6.414l3.293 3.293a1 1 0 11-1.414 1.414l-5-5a1 1 0 010-1.414l5-5a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg><span>Back</span></a> </nav> <article class="flex flex-col items-start"> <div class="flex flex-wrap items-start justify-start gap-x-5 gap-y-2 text-xs md:text-sm text-neutral-500 dark:text-neutral-300 mb-8"> <span class="inline-flex items-center gap-2 shrink-0"> <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5 text-neutral-500 dark:text-neutral-300" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v4"></path><path d="M16 2v4"></path><rect width="18" height="18" x="3" y="4" rx="2"></rect><path d="M3 10h18"></path><path d="M8 14h.01"></path><path d="M12 14h.01"></path><path d="M16 14h.01"></path><path d="M8 18h.01"></path><path d="M12 18h.01"></path><path d="M16 18h.01"></path></svg> <time datetime="2025-09-01T00:00:00.000Z"> Sep 1, 2025 </time> </span> <span class="inline-flex items-center gap-2 shrink-0"> <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="w-5 h-5 text-neutral-500 dark:text-neutral-300" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M464 256A208 208 0 1 1 48 256a208 208 0 1 1 416 0zM0 256a256 256 0 1 0 512 0A256 256 0 1 0 0 256zM232 120l0 136c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2 280 120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"></path></svg> 12 min read
</span> <span class="inline-flex items-center gap-2 shrink-0"> <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="w-5 h-5 text-neutral-500 dark:text-neutral-300" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M440.667 182.109l7.143-40c1.313-7.355-4.342-14.109-11.813-14.109h-74.81l14.623-81.891C377.123 38.754 371.468 32 363.997 32h-40.632a12 12 0 0 0-11.813 9.891L296.175 128H197.54l14.623-81.891C213.477 38.754 207.822 32 200.35 32h-40.632a12 12 0 0 0-11.813 9.891L132.528 128H53.432a12 12 0 0 0-11.813 9.891l-7.143 40C33.163 185.246 38.818 192 46.289 192h74.81L98.242 320H19.146a12 12 0 0 0-11.813 9.891l-7.143 40C-1.123 377.246 4.532 384 12.003 384h74.81L72.19 465.891C70.877 473.246 76.532 480 84.003 480h40.632a12 12 0 0 0 11.813-9.891L151.826 384h98.634l-14.623 81.891C234.523 473.246 240.178 480 247.65 480h40.632a12 12 0 0 0 11.813-9.891L315.472 384h79.096a12 12 0 0 0 11.813-9.891l7.143-40c1.313-7.355-4.342-14.109-11.813-14.109h-74.81l22.857-128h79.096a12 12 0 0 0 11.813-9.891zM261.889 320h-98.634l22.857-128h98.634l-22.857 128z"></path></svg> <span class="inline-flex items-center gap-1"> <span class="inline-flex items-center"> <a href="/tags/messaging" class="hover:underline active:underline underline-offset-4
                                                               lg:hover:text-cyan-600 lg:dark:hover:text-prnd-neon
                                                               active:text-cyan-600 dark:active:text-prnd-neon
                                                               transition-colors"> messaging </a> <span class="mx-1">/</span> </span><span class="inline-flex items-center"> <a href="/tags/streaming" class="hover:underline active:underline underline-offset-4
                                                               lg:hover:text-cyan-600 lg:dark:hover:text-prnd-neon
                                                               active:text-cyan-600 dark:active:text-prnd-neon
                                                               transition-colors"> streaming </a>  </span> </span> </span> <span class="inline-flex items-center gap-2 shrink-0"> <svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5 text-neutral-500 dark:text-neutral-300" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg> <a href="#about-author" class="italic hover:underline active:underline underline-offset-4">by Andrii Popov</a> </span> </div> <!--I do not display image by default!-->  <div class="w-full text-left"> <h1 class="text-3xl font-medium leading-8 tracking-normal mb-6">Messaging vs streaming: core architectural differences</h1> <p class="text-base/6 sm:text-lg/7 font-normal italic tracking-normal dark:text-neutral-200">
"In this article, we explore core architectural differences between messaging and streaming concepts, define boundaries and discuss use cases"</p> <hr class="h-px border-0 mt-6 mb-4 w-full bg-gradient-to-r from-neutral-500 to-transparent"> </div> <!-- Pagefind enhancements --> <div class="hidden" data-pagefind-meta="title"> Messaging vs streaming: core architectural differences </div> <div class="hidden" data-pagefind-meta="description"> In this article, we explore core architectural differences between messaging and streaming concepts, define boundaries and discuss use cases </div> <div class="hidden" data-pagefind-meta="tags"> messaging, streaming </div> <!-- ⭐ Add image to Pagefind metadata --> <div class="hidden" data-pagefind-meta="image"> /_astro/cover.Dvd4mVuM.webp </div> <div class="markdown-content w-full" data-pagefind-body>  <p>There is a fair share of misunderstanding across even seasoned engineers when it comes to <em>messaging</em> vs <em>streaming</em>. I’ve seen developers - including myself in the past:) - struggle to clearly separate these two classes of systems and often mix concepts that are inherent to each.</p>
<p>If a company already runs on a streaming stack across the project, does it still need messaging? Usually, <strong>no</strong>.<br/>
If a company already relies on message queues, will it ever need a streaming platform? Often, <strong>yes</strong>.</p>
<p>Below I explore the core architectural differences of these systems to identify strengths, weaknesses, trade-offs and key use cases.</p>
<p>But first, let’s analyze the retrospective evolution of inter-service interaction in backend systems to better understand where <em>we’ve been</em> and where <em>we are now</em>.</p>
<h2 id="retrospective-evolution-of-async-interaction">Retrospective: evolution of async interaction<a class="autolink" aria-label="Link to this heading" href="#retrospective-evolution-of-async-interaction">#</a></h2>
<h3 id="early-era-rpc-everywhere">Early era: RPC everywhere<a class="autolink" aria-label="Link to this heading" href="#early-era-rpc-everywhere">#</a></h3>
<p>The first generation of distributed systems — roughly the late <strong>1990s</strong> to <strong>mid-2000s</strong> — was dominated by <em>Remote Procedure Call</em> (RPC) thinking. Everything looked like a <em>function call</em>, but over a network. The industry mindset at the time assumed: networks are (mostly) reliable, latency is negligible compared to compute. As a result, systems behaved like one <em>giant monolith</em> distributed across machines. This stage introduced: a) <em>synchronous semantics</em>: every request blocks; b) <em>tight coupling</em>: caller and callee must be alive. Core problems were: if a downstream service slowed or died - callers froze or cascaded failures. E.g. a burst of <em>10k</em> requests/s against a downstream that could handle <em>~3k/s</em> caused blocking threads, queue overflow, retry storms — and the system collapsed.</p>
<h3 id="rise-of-message-queues">Rise of Message queues<a class="autolink" aria-label="Link to this heading" href="#rise-of-message-queues">#</a></h3>
<p>By the early <strong>2000s</strong>, the limits of synchronous RPC became painfully visible. The industry needed a mechanism that: absorbs load spikes, retries failures, decouples producers from consumers, does not require both sides to be online at the same time. Message queues became that mechanism — and they fundamentally changed how distributed systems were built. <em>Asynchronous</em> processing becomes natural: email sending, payment processing, invoicing, long-running tasks — finally handled off the main request path. Queues solved critical problems — but they also revealed new ones that later pushed the industry toward streaming systems: destructive consumption (no history, no replay), single-consumer semantic, no horizontal scalability, limited observability, like you see counts (e.g., <em>“X messages in queue”</em>) but not the full ordered sequence.</p>
<h3 id="rise-of-distributed-logs">Rise of Distributed logs<a class="autolink" aria-label="Link to this heading" href="#rise-of-distributed-logs">#</a></h3>
<p>By the early <strong>2010s</strong>, the limitations of traditional message queues became impossible to ignore. A new abstraction emerged to fill the gap: the distributed <em>append-only log</em>. <em>Apache Kafka</em> was the first system to popularize this log as a first-class architectural primitive, and this fundamentally changed how engineers thought about data, workflows, and system boundaries. The key innovations — non-destructive consumption, replayability, horizontal scalability through partitions, and multiple consumer groups — shifted the industry from task-oriented queues to fact-oriented event streams. This shift — from <em>what to execute</em> to <em>what happened</em> — was the key conceptual leap. Additionally, streaming engines like <em>Apache Flink</em>, <em>Spark Streaming</em>, and <em>Kafka Streams</em> added rich event-time semantics, windowing, and continuous computation, enabling new workloads: analytics, telemetry pipelines, fraud detection, ML feature processing, and event-sourced systems. Logs solved the intrinsic limitations of queues, and became the backbone of modern real-time architectures.</p>
<p>Now, it’s time to dive deeper into the internal architectures of messaging and streaming systems.</p>
<h2 id="messaging-queues">Messaging Queues<a class="autolink" aria-label="Link to this heading" href="#messaging-queues">#</a></h2>
<p>As stated above, a message broker is a standalone, separately deployable application whose primary goal is to enable <em>asynchronous</em> task processing and service <em>decoupling</em>.</p>
<h3 id="how-it-works-conceptually">How it works conceptually?<a class="autolink" aria-label="Link to this heading" href="#how-it-works-conceptually">#</a></h3>
<p><strong>Producer</strong>. A <em>producer</em> (can be an application, device or a person) sends a message to a queue’s (<em>topic</em>, <em>exchange</em> or any other <em>“front door”</em>) over the network. The queue may operate in <em>fire-and-forget</em> mode or return a <a href="https://www.rabbitmq.com/tutorials/tutorial-seven-java#publisher-confirms" rel="noopener noreferrer" target="_blank"><em>“publish confirmation”</em></a> — either synchronously or asynchronously — indicating that the broker has accepted and persisted the message. Confirmation mode is recommended for applications where message loss is unacceptable.</p>
<p><strong>Storage</strong>. At the broker side, messages are stored in format-agnostic form — <em>raw bytes</em> — the content is not inspected or modified by the broker. It is up to producers and consumers to agree on the serialization format. Most popular formats are <em>JSON/AVRO/Protobuf</em>, etc. However, in classic message queues, serialization format has almost no impact on throughput; for sustainable <em>hundreds/few thousands</em> RPS workloads and reasonably small messages (<em>few Kb</em>), JSON is a perfectly reasonable default due to its simplicity, readability, and universal tooling support. A message remains in the queue until it is <em>acknowledged</em> by a consumer (the broker receives a response from a consumer) or expires, if <em>TTL</em> (Time To Live is configured). Physically, messages are persisted on the broker’s local storage (SSD/NVMe), though exact placement depends on the broker type and durability settings (in-memory, disk-backed, replicated, etc.).</p>
<p><strong>Consumers</strong>. Consumers may <em>pull</em> from the queue or receive <em>pushed</em> messages. This depends on broker type and configuration. In push-based mode, the broker typically tracks all connected consumers and distributes messages using a <a href="https://www.rabbitmq.com/docs/consumer-priority#overview" rel="noopener noreferrer" target="_blank"><em>“round-robin”</em></a> strategy. When a message is delivered to a consumer, it enters an <em>unacked buffer</em> (a <strong>linked-list-like</strong> structure per consumer, see <strong>Fig. 1</strong>) at broke’s side and remains there until <em>acknowledged</em> by a consumer. The <em>“linked-list-like”</em> description is an approximation(!) — different brokers may use alternative internal data structures with similar semantics. Once the consumer processes the message, it must send either an acknowledgment (<code>ACK</code>) or a negative acknowledgment (<code>NACK</code>) for that message back to the broker; upon receiving a positive <code>ACK</code>, the broker immediately removes the message from its internal storage and considers it fully delivered.</p>
<p><strong>Re-delivery</strong>. Most brokers introduce some sort of <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html" rel="noopener noreferrer" target="_blank"><em>“visibility timeout”</em></a> (in terms of AWS SQS) - a small interval (measured in <em>sec-s</em> or <em>min-s</em>) during which a delivered message stays in unacked buffer and becomes temporarily invisible to all other consumers. An internal broker <em>timer</em> measures the time elapsed since the message was delivered to a consumer, see <strong>Fig.1</strong>. If the consumer crashes or fails to acknowledge in time, the broker automatically <em>re-queues</em> the message once the timeout expires. <em>Re-queueing</em> means the message is moved from the unacked buffer back to the main queue, making it eligible for delivery again. <em>“Visibility timeout”</em> is a broker-side protection against stalled consumers: it prevents messages from getting stuck unprocessed. Its behavior is <em>broker-specific</em> (per-message, per-consumer, or unsupported), and the timeout should be tuned to roughly match the expected processing time of a typical message. If it’s too short, messages may be redelivered prematurely, causing <em>double-processing</em>; if it’s too long, stalled consumers delay recovery and make callers wait longer.</p>
<p><strong>Dead-lettering</strong>. Most brokers support <em>dead-lettering</em>, but it is not enabled by default — it must be configured at the broker or queue level. This is a special mechanism designed to handle <em>poison messages</em> — those that cannot be successfully processed even after multiple delivery attempts. You can configure the number of delivery attempts (say <strong>3-5</strong>) after which the message is automatically forwarded to the <strong>DLQ</strong> (Dead Letter Queue), see <strong>Fig. 1</strong>. In most brokers, each message carries an internal delivery-attempt <em>counter</em>. Every failed, rejected, or timed-out delivery increments this counter. Once it reaches the configured limit, the broker’s routing logic automatically sends the message to the DLQ. Messages accumulated in a DLQ can later be inspected, corrected, and re-queued for processing.</p>
<p><strong>Clustering</strong>. Brokers can be clustered and this is a typical production set-up. In a broker cluster, a queue is typically owned by one <em>leader</em> node and <em>asynchronously</em> replicated to <em>follower</em> nodes. But from the caller’s perspective the operation may appear <em>synchronous</em> because the system delays the acknowledgement until replicas confirm writes. This improves higher <em>availability</em> and <em>fault tolerance</em>, but does not make the queue itself <em>horizontally scalable</em> — all writes and reads still pass through a single leader. You cannot add a new broker node at runtime to increase the backlog capacity of an existing queue. For this reason, the storage size of each broker must be planned in advance to accommodate the expected backlog, unless you are using a cloud-native queue service, which can grow its storage capacity transparently (<a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-queues.html" rel="noopener noreferrer" target="_blank"><em>indefinitely</em></a> in case of AWS SQS). <a href="https://raft.github.io/" rel="noopener noreferrer" target="_blank"><em>Raft</em></a> is gaining traction for building strongly consistent, leader-based queue replication, but many established message brokers continue to depend on custom, vendor-defined clustering mechanisms.</p>
<figure class="m-6 text-center"> <img src="/_astro/messaging-scheme.C-rksVjI_ZW4ENo.webp" alt="Message broker model" loading="lazy" decoding="async" fetchpriority="auto" width="731" height="541"> <figcaption class="mt-2 text-sm text-neutral-600 dark:text-neutral-300"> <strong>Fig. 1. </strong> <p>Conceptual model shared by most message brokers. Broker-specific storage / clustering details are intentionally omitted.</p> </figcaption> </figure>

<h2 id="streaming-platforms">Streaming Platforms<a class="autolink" aria-label="Link to this heading" href="#streaming-platforms">#</a></h2>
<p>A <em>streaming platform</em> is also a standalone system, but it is designed for very <em>high-throughput</em> event ingestion — often <em>hundreds of thousands</em> to <em>millions</em> of events per second — while ensuring <em>durability</em> and supporting <em>multiple independent consumers</em> reading the same data. While streaming platforms are also <em>asynchronous</em> systems, asynchronicity is not their defining characteristic. So, let’s have a deeper look at how they work.</p>
<h3 id="how-it-works-conceptually-1">How it works conceptually?<a class="autolink" aria-label="Link to this heading" href="#how-it-works-conceptually-1">#</a></h3>
<p><strong>Producer</strong>. A producer (again being an application, device or even a human-triggered action) writes events to a <em>topic</em> and each event may include a <em>key</em> that determines ordering and routing. The streaming platform applies a <em>hash</em> function to this key to select a <em>partition</em>, which is simply an <em>append-only, immutable</em> log file, see <strong>Fig. 2</strong>. All events with the same key land in the same partition, preserving strict per-key <em>ordering</em>. Producers operate fully <em>asynchronously</em>: they append to a remote log without waiting for consumers or coordinating with them.
Streaming platforms also acknowledge writes to the producer — effectively the same idea as <em>“publisher confirms”</em>, just under different terminology. In self-managed systems (e.g., Kafka, Pulsar), the acknowledgement level is a first-class architectural decision because it defines how many nodes must persist an event before writing is considered successful (e.g. in <a href="https://kafka.apache.org/documentation/#producerconfigs_acks" rel="noopener noreferrer" target="_blank"><em>Kafka</em></a> <code>ack</code> = <em>0 | 1 | all</em>). In fully managed cloud services (e.g., <em>AWS Kinesis</em>), this durability level is fixed by the provider and not user-tunable. This param directly defines how trustworthy the log is as a long-term <em>source of truth</em> and is typically chosen upfront as part of the system’s overall durability model.</p>
<p><strong>Storage</strong>. Under the hood, each <em>partition</em> is an <strong>append-only, immutable log</strong> that grows sequentially on disk. Events are never mutated or removed on consumption — instead, they accumulate as a durable <em>history</em> that can be scanned, replayed, or compacted depending on the <em>retention policy</em> (see below). Because writes are sequential and disks are optimized for sequential I/O, partitions deliver extremely high ingestion throughput. Physically, events are stored as <em>raw byte</em> records with minimal metadata (offset, timestamp, and a small header). The broker does not interpret or validate the payload; just as in the case of message brokers, serialization is entirely the responsibility of producers and consumers. In practice, compact binary formats (<a href="https://avro.apache.org/docs/" rel="noopener noreferrer" target="_blank"><em>Avro</em></a>, <em>Protobuf</em>, etc.) often become essential at scale because they reduce both serialization cost and wire size, allowing the log to absorb significantly higher traffic.
Overall, this <em>durable log</em> abstraction is what differentiates streaming systems from message queues: storage is not a transient buffer but an architectural primitive that preserves the full timeline of events.</p>
<p><strong>Consumer (groups)</strong>. Consumption is organized around <em>consumer groups</em> — coordinated set of consumers that together read from a topic as a single <em>logical</em> application. Depending on the platform, consumption may be pull-based (<em>Kafka</em>), push-based (<em>Pulsar</em>) or configured (<em>AWS Kinesis</em>). Multiple <em>consumer groups</em> may independently process the same messages. After processing records, consumers explicitly commit their new read position (<em>offset</em>) back to the broker that stores it durably, and then issue another fetch request to the partition for the next batch of events. Conceptually, this can be viewed as a persistent key-value table indexed by <code>{topic, partition, consumer group}</code> = <code>offset</code>, allowing consumers to resume exactly where they left off after failures or restarts ensuring <code>at-least-once</code> delivery semantics. The exact storage mechanism and coordination details are platform-dependent.
Because partitions are independent, consumer groups can scale horizontally: multiple instances within the same group divide the partitions among themselves, enabling parallel processing while preserving per-partition ordering. Rules that apply:</p>
<p><strong>Rule #1</strong></p>
<blockquote>
<p><em>A partition can be read by at most one consumer instance in a group</em>. This preserves ordering and prevents duplicate processing inside the group.</p>
</blockquote>
<p><strong>Rule #2</strong></p>
<blockquote>
<p><em>A single consumer instance can read from multiple partitions</em>. When there are fewer consumer instances in a group than partitions, the workload is distributed by assigning several partitions to each instance.</p>
</blockquote>
<p>These two rules are <em>universal</em> across all mainstream log-based streaming platforms as they fall out of the combination of the append-only log model, ordering and scaling requirements.</p>
<p><strong>Fig. 2</strong> illustrates how partitions are consumed by different consumer groups. Group <strong>B</strong> has a single instance (B1), so it receives all partitions of the topic. Group <strong>A</strong> has two instances (A1 and A2), so the partitions are split between them (for example, A1 reads from P0 while A2 reads from P1 and P2).</p>
<p><strong>Retention (policy)</strong>. Retention defines <em>how long</em> or <em>how much</em> data a log-based streaming platform keeps — independently of whether consumers have read it. This is very different from message brokers, where messages disappear once acknowledged. In streaming platforms, events remain in partitions for a defined <em>retention period</em> (hours, days, or indefinitely, e.g. in <em>Kafka</em> default value is <a href="https://kafka.apache.org/documentation/#topicconfigs_retention.ms" rel="noopener noreferrer" target="_blank"><em>7 days</em></a>), independent of consumer progress. The platform’s background sub-system periodically (every <a href="https://kafka.apache.org/documentation/#brokerconfigs_log.retention.check.interval.ms" rel="noopener noreferrer" target="_blank"><em>5 mins</em></a> by default for <em>Kafka</em>) evaluates log segments and removes or compacts old data according to the configured retention strategy — <em>by time</em>, <em>by size</em>, or a combination of both.
Retention is what turns the log into a <em>bounded</em>, maintainable structure while still allowing consumers to replay historical data, rebuild state, or backfill analytics pipelines.
Increasing the number of partitions increases parallelism and ingestion throughput, but it also increases the total stored volume subject to retention rules, making retention a key lever in balancing cost, durability, and performance.</p>
<p><strong>Clustering</strong>. Clustering is typically more complex and more <em>central</em> than in classic message brokers. In practice, streaming platforms are almost never deployed as a single node and are architected for <em>clustering</em> by default — recovery, partitioning, replication, leader election, and consumer parallelism all rely on multiple nodes working together. A cluster presents itself as a single logical log system, while physically each node stores and serves a subset of partitions, allowing ingestion and consumption throughput to scale <em>linearly</em> as more nodes are added. Partitions are distributed across different machines, and each partition has an active <em>leader</em> along with one or more <em>replicas</em> placed on other nodes. The <em>replication factor</em> (RF) tells you how many copies of each partition exist in the cluster. Partition placement is determined by the cluster’s <em>control plane</em> — a specialized component responsible for metadata, coordination, and consistency. Producers always write to the leader, which then replicates new records to its replicas (usually <em>asynchronously</em>), ensuring that a node failure does not result in the loss of committed events. Consumers automatically <em>rebalance</em> when nodes join or leave the cluster, redistributing partition ownership to maintain parallelism and performance.
This cross-node placement of leaders and replicas provides both horizontal performance scaling and the fault tolerance expected from a modern streaming platform.</p>
<figure class="m-6 text-center"> <img src="/_astro/streaming-scheme.BCMorr8t_1HHXCr.webp" alt="Streaming platform model" loading="lazy" decoding="async" fetchpriority="auto" width="961" height="691"> <figcaption class="mt-2 text-sm text-neutral-600 dark:text-neutral-300"> <strong>Fig. 2. </strong> <p>Conceptual model common to log-based streaming systems. Cluster topology is intentionally omitted.</p> </figcaption> </figure>

<h2 id="conclusion">Conclusion<a class="autolink" aria-label="Link to this heading" href="#conclusion">#</a></h2>
<p>Having explored both types of systems it becomes obvious that despite sharing some common features like <em>async processing</em>, <em>decoupling producers and consumers</em>, etc. these are completely different kinds of systems. And it’s time to answer the main question: <strong>how to choose the right system for a project</strong>?
Unfortunately, there is no <em>single recipe</em> or <em>universal algorithm</em> for selecting a baseline system. What does work <em>in practice</em> is a small set of baseline strategies:</p>
<p><strong>Start with messaging</strong>. Choose a <em>message broker</em> as your baseline if your domain is mostly <em>tasks</em>: emails sending, image processing, billing retries, webhook delivery, etc. You expect <em>moderate amount</em> of jobs, measured in hundreds, low thousands per sec. You are satisfied with <em>destructive consumption</em>: a message is taken from the queue and processed once, then after acknowledgement is removed <em>forever</em>.</p>
<p><strong>Start with streaming</strong>. Choose a <em>streaming platform</em> as your baseline if your domain is mostly <em>events / facts</em>. You expect <em>huge amount</em> of events per sec (hundreds of thousands and even millions), that may increase in the future as system develops. You expect <em>multiple</em> independent consumers and evolving read-models. You need configurable <em>retention</em> and <em>replay</em>.</p>
<p><strong>Hybrid</strong>. This setup is common in mature systems, even though is more expensive, and uses both streaming and messaging, with a clean <em>boundary</em>: <em>streaming</em> for event ingesting with potentially high throughput and <em>messaging</em> for operational tasks like delayed jobs with retries and native handling of <em>poisoned messages</em>. This avoids forcing one system to imitate the other.</p>
<p>Indeed, streaming systems can <em>imitate</em> messaging semantics by using a single consumer group, where each partition is consumed by only one consumer instance at a time, effectively approximating a distributed messaging queue. However, core messaging features such as <em>retries</em>, <em>delayed redelivery</em>, <em>backoff</em>, and <em>dead-letter</em> handling are typically not broker-native in streaming platforms and are instead implemented at the application level by consumers. This is most commonly achieved by forwarding failed records to dedicated <a href="https://www.confluent.io/blog/error-handling-patterns-in-kafka" rel="noopener noreferrer" target="_blank"><em>error/retry topics</em></a>, which are then consumed and processed according to application-defined rules.</p>
<p>Conversely, some modern message brokers provide <em>streaming-like</em> capabilities. For example, <em>RabbitMQ</em> offers <a href="https://www.rabbitmq.com/docs/streams" rel="noopener noreferrer" target="_blank"><em>Streams</em></a>, including partitioned streams via Super Streams. However, this does not make RabbitMQ a full-fledged streaming platform in terms of ergonomics and operational model. RabbitMQ remains a general-purpose message broker and must support multiple messaging data structures and delivery semantics, which limits how far it can <em>optimize</em> around a single append-only log in the way Kafka does. Some community <a href="https://dou.ua/forums/topic/50318/" rel="noopener noreferrer" target="_blank">authors</a> have also noted that <em>RabbitMQ Streams</em> and their client ecosystem are <em>less mature</em> than established streaming platforms, pointing to gaps in tooling, client libs behavior, and operational ergonomics observed in production scenarios.</p>
<p>Overall, message brokers are designed to solve a <em>narrower</em> class of problems, centered around task distribution and delivery semantics, and are <em>not optimized</em> for extreme ingestion rates or log-centric horizontal scaling. Streaming platforms, by contrast, are built to sustain high-throughput event ingestion and <em>fan-out</em> by treating the log itself as the primary scalability and durability primitive.</p>
<p>Ultimately, the choice between messaging and streaming should be driven by system scale, data retention needs, and consumption patterns — not by <em>familiarity</em> with a particular tool or ecosystem.</p>  </div> </article> <hr class="h-px border-0 my-6 w-full bg-gradient-to-r from-neutral-500 to-transparent"> <nav aria-label="Previous and next articles" class="grid grid-cols-2 gap-5"><div class="flex flex-col items-start gap-3
                p-2
                text-sm
                bg-transparent
                border border-zinc-500
                rounded-sm"><p class="font-normal text-zinc-600 dark:text-zinc-300">Previous</p><a href="/posts/observability-vs-profiling/" class="
                inline-flex items-center gap-2
                font-semibold
                text-neutral-600 dark:text-prnd-neon hover:scale-101 active:scale-99"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="shrink-0 w-4 h-4 text-neutral-600 dark:text-prnd-neon" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" d="M0 0h24v24H0z"></path><path d="M17.59 18 19 16.59 14.42 12 19 7.41 17.59 6l-6 6z"></path><path d="m11 18 1.41-1.41L7.83 12l4.58-4.59L11 6l-6 6z"></path></svg><span>Observability vs profiling: where observability ends and profiling starts</span></a></div><div class="flex flex-col items-end gap-3
                p-2
                text-sm
                bg-transparent
                border border-zinc-500
                rounded-sm"><p class="font-normal text-zinc-600 dark:text-zinc-300">Next</p><a href="/posts/rabbit-mq-overview/" class="
                inline-flex items-center gap-2
                font-semibold
                text-neutral-600 dark:text-prnd-neon hover:scale-101 active:scale-99"><span class="text-right">Rabbit MQ: surprises and frustrations</span><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" class="shrink-0 w-4 h-4 text-neutral-600 dark:text-prnd-neon" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" d="M0 0h24v24H0z"></path><path d="M6.41 6 5 7.41 9.58 12 5 16.59 6.41 18l6-6z"></path><path d="m13 6-1.41 1.41L16.17 12l-4.58 4.59L13 18l6-6z"></path></svg></a></div></nav> <hr class="h-px border-0 my-6 w-full bg-gradient-to-r from-neutral-500 to-transparent"> <aside id="about-author" class="mt-0 pt-6"> <section> <div class="flex gap-4 rounded-2xl bg-zinc-100/70 dark:bg-neutral-800/60 px-4 py-4 sm:px-5 sm:py-5"> <div class="shrink-0"> <img src="/_astro/avatar.h0uefq9r_Z1i5gFo.webp" alt="Andrii Popov" loading="lazy" decoding="async" fetchpriority="auto" width="259" height="259" class="h-12 w-12 rounded-full bg-neutral-300 dark:bg-neutral-600"> </div> <div class="space-y-2 text-sm leading-relaxed"> <h2 class="text-xs font-semibold uppercase tracking-wide text-neutral-500">
About the author
</h2> <p class="font-medium text-neutral-900 dark:text-neutral-50">
Andrii Popov · Popov R&amp;D — Independent Engineering Lab
</p> <p class="text-neutral-700 dark:text-neutral-300">
Senior Java &amp; React engineer focused on practical JVM performance,
                Spring ecosystem, and modern front-end tooling. I run independent
                Popov R&amp;D experiments and write about what actually works in production.
</p> <p class="text-neutral-700 dark:text-neutral-300">
If you’d like to collaborate, feel free to reach out on LinkedIn.
</p> <ul class="flex flex-wrap gap-3 pt-1 text-xs"> <li> <a href="https://popov-rnd.com" class="inline-flex items-center gap-1 hover:underline underline-offset-4"> <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="w-5 h-5 text-cyan-600 dark:text-cyan-200 hover:scale-110 active:scale-95" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill="none" stroke-miterlimit="10" stroke-width="32" d="M256 48C141.13 48 48 141.13 48 256s93.13 208 208 208 208-93.13 208-208S370.87 48 256 48z"></path><path fill="none" stroke-miterlimit="10" stroke-width="32" d="M256 48c-58.07 0-112.67 93.13-112.67 208S197.93 464 256 464s112.67-93.13 112.67-208S314.07 48 256 48z"></path><path fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M117.33 117.33c38.24 27.15 86.38 43.34 138.67 43.34s100.43-16.19 138.67-43.34m0 277.34c-38.24-27.15-86.38-43.34-138.67-43.34s-100.43 16.19-138.67 43.34"></path><path fill="none" stroke-miterlimit="10" stroke-width="32" d="M256 48v416m208-208H48"></path></svg> <span>Website</span> </a> </li> <li> <a href="https://www.linkedin.com/in/Popov85/" class="inline-flex items-center gap-1 hover:underline underline-offset-4"> <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" class="w-5 h-5 text-neutral-800 dark:text-neutral-300 hover:scale-110 active:scale-95" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg> <span>LinkedIn</span> </a> </li> <li> <a href="https://github.com/Popov85" class="inline-flex items-center gap-1 hover:underline underline-offset-4"> <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 496 512" class="w-5 h-5 text-neutral-800 dark:text-neutral-300 hover:scale-110 active:scale-95" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg> <span>GitHub</span> </a> </li> </ul> </div> </div> </section> </aside> </main> <script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();</script><astro-island uid="Z2fQQ55" prefix="r11" component-url="/_astro/ScrollToTopButton.P8reXH2a.js" component-export="ScrollToTopButton" renderer-url="/_astro/client.B_PwMJWB.js" props="{}" ssr client="load" opts="{&quot;name&quot;:&quot;ScrollToTopButton&quot;,&quot;value&quot;:true}" await-children><button aria-label="Scroll to top" class="
                fixed bottom-6 right-6 z-[999]
                flex items-center justify-center
                w-12 h-12 rounded-full
                bg-neutral-700 dark:bg-neutral-200
                text-neutral-200 dark:text-neutral-700
                shadow-lg shadow-black/25
                transition-all duration-300
                active:scale-95
                lg:hidden
                opacity-0 pointer-events-none
              "><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" class="text-2xl active:text-prnd-neon" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M256 217.9L383 345c9.4 9.4 24.6 9.4 33.9 0 9.4-9.4 9.3-24.6 0-34L273 167c-9.1-9.1-23.7-9.3-33.1-.7L95 310.9c-4.7 4.7-7 10.9-7 17s2.3 12.3 7 17c9.4 9.4 24.6 9.4 33.9 0l127.1-127z"></path></svg></button><!--astro:end--></astro-island> <footer class="mt-auto">  <hr class="mx-auto my-8 border-t border-neutral-300 dark:border-neutral-400 max-w-lg"> <div class="text-xs text-neutral-500 dark:text-neutral-300 flex flex-col justify-center items-center gap-1 pb-6"> <div><span>© 2026 Popov R&amp;D</span></div> <div>All rights reserved.</div> </div> </footer> </body></html>